# -*- coding: utf-8 -*-
"""
Created on Mon Apr 17 11:31:12 2023

@author: jmcle
"""


## E&M II Final Project
# In this project, the aim is to find the Electric field around the Earth, 
# generated by its rotating magnetic field 
# Jodie McLennan April 2023

import numpy as np
from matplotlib import pyplot as plt
from scipy.integrate import ode
from matplotlib.patches import Circle
import matplotlib.animation as manimation



#%% Initialize Magnetic Field
# Define constants
mu0 = 4*np.pi*10**(-7)
k0 = 8*10^(15) #Tm^3
#k0 = mu0*m/(4*np.pi)
R_e = 6371200 # radius of the earth (m), 6371.2 km 
B0 = 312e-7 # mean vlaue of B field at equator on earth's surface (31.2 muT)
alpha = np.radians(11.7) # tilt of the earth
qcharge = 1.6e-19
me = 9.1e-31 #mass of electron
mp = 1.6e-27 #mass of proton


# gryro motion:

def Lorentz(t, Y, q, m, B):
    """Computes the derivative of the state vector y according to the equation of motion:
    Y is the state vector (x, y, z, u, v, w) === (position, velocity).
    returns dY/dt.
    """
    # B in x direction..
    x, y, z = Y[0], Y[1], Y[2]
    u, v, w = Y[3], Y[4], Y[5]
    
    alpha = q / m * B
    
    # B in any direction:
    # Ex,Ey,Ez + Bx,By,Bz
    # alpha  = q/m
    #dy/dt = [u , v , w , ax , ay, az]
    #vBx = v*Bz - w*By
    #vBy = w*Bx - u*Bz
    #vBz = u*By - v*Bx
    #ax = alpha*(Ex+vBx)
    #ay = alpha*(Ey+vBy)
    #az = alpha*(Ez+vBz)
    #return np.array([u,v,w,ax,ay,az])
    
    return np.array([u, v, w, 0, alpha * w, -alpha * v])

def Lorentzv2(t, Y, q, m, B, E):
    """Computes the derivative of the state vector y according to the equation of motion:
    Y is the state vector (x, y, z, u, v, w) === (position, velocity).
    returns dY/dt.
    """
    # B in x direction..
    x, y, z = Y[0], Y[1], Y[2]
    u, v, w = Y[3], Y[4], Y[5]
    
    #alpha = q / m * B
    
    # B in any direction:
    # Ex,Ey,Ez + Bx,By,Bz
    Bx ,By, Bz = B[0], B[1], B[2]
    Ex, Ey, Ez = E[0], E[1], E[2]
    
    alpha  = q/m
    #dy/dt = [u , v , w , ax , ay, az]
    

    vBx = v*Bz - w*By
    vBy = w*Bx - u*Bz
    vBz = u*By - v*Bx
    ax = alpha*(Ex+vBx)
    ay = alpha*(Ey+vBy)
    az = alpha*(Ez+vBz)
    #print(vBx,vBy,vBz)
    return np.array([u,v,w,ax,ay,az])


# bounce motion:
def bounceVelocity(t,Y,q,m,B,mu):
    x, y, z = Y[0], Y[1], Y[2]
    u, v, w = Y[3], Y[4], Y[5]
    Bx ,By, Bz = B[0], B[1], B[2]
    B2 = Bx**2+By**2+Bz**2
    bhat = B/np.sqrt(B2)
    #Bmirror = 
    vperp = np.sqrt(2*mu*B/m)
    
    return vperp

def secondAdiabtic(x,y,z,Bm,m):
    r_dist = r(x,y,z)
    Beq = B0*(R_e/r_dist)**3
    sin2a = (4*(R_e*r)**6-3*(R_e*r)**5)**(-1/2)
    Bm = Beq/sin2a
    #I = m*vperp/Bm
    

# drift motion:
def drfitVelocityv2(t, Y, q, m, B, E, Rc):
    """Computes the derivative of the state vector y according to the equation of motion:
    Y is the state vector (x, y, z, u, v, w) === (position, velocity).
    returns dY/dt.
    """
    # B in x direction..
    x, y, z = Y[0], Y[1], Y[2]
    u, v, w = Y[3], Y[4], Y[5]
    
    alpha = q / m * B
    
    # B in any direction:
    # Ex,Ey,Ez + Bx,By,Bz
    Bx ,By, Bz = B[0], B[1], B[2]
    Ex, Ey, Ez = E[0], E[1], E[2]
    Rcx, Rcy, Rcz = Rc[0], Rc[1], Rc[2]
    
    ax,ay,az = 0,0,0
    alpha  = q/m
    #dy/dt = [u , v , w , ax , ay, az]
    # vBx = v*Bz - w*By
    # vBy = w*Bx - u*Bz
    # vBz = u*By - v*Bx
    # ax = alpha*(Ex+vBx)
    # ay = alpha*(Ey+vBy)
    # az = alpha*(Ez+vBz)
    
    
    B2 = Bx**2 + By**2 + Bz**2
    Rc2 = Rcx**2 + Rcy**2 + Rcz**2
    bhat = B/np.sqrt(B2)
    v = np.array([u,v,w])
    vpar2 = (bhat[0]*u)**2 + (bhat[1]*v)**2 + (bhat[2]*w)**2
    Vperp = np.cross(bhat,v)
    vperp2 = Vperp[0]**2 + Vperp[1]**2 + Vperp[2]**2
    xhat = Rcy*Bz - Rcz*By
    yhat = Rcz*Bx - Rcx*Bz
    zhat = Rcx*By - Rcy*Bx
    coeff = m/q * (vpar2 + 0.5*vperp2)
    velx = coeff/(B2*Rc2)*xhat
    vely = coeff/(B2*Rc2)*yhat
    velz = coeff/(B2*Rc2)*zhat
    #vel= 1/q*(m*vpar**2+.5*m*vperp**2)*(np.cross(Rc,Bvec)/(Rc*B)**2)
    return np.array([velx,vely,velz,ax,ay,az])


def driftvel(q,vpar,vperp,Rc,Br,Btheta,Bphi):
    B = np.sqrt(Br**2+Btheta**2+Bphi**2)
    Bvec = [Br,Btheta,Bphi]
    vel= 1/q*(m*vpar**2+.5*m*vperp**2)*(np.cross(Rc,Bvec)/(Rc*B)**2)
    return vel 


###########################################################
#SOLVE#############
def LorentzF(t,Y,q,m,B,E):
    x, y, z = Y[0], Y[1], Y[2]
    u, v, w = Y[3], Y[4], Y[5]
    aNext = q*(E+np.cross(Y[3:-1],B))
    return np.array([u,v,w,aNext[0],aNext[1],aNext[2]])
#LorentzF = lambda t,v,q,m,B,E: q*(E+np.cross(v,B))
#runge kutta solver:
def rk4_solver(f, y0, t0, q, m, B0, E0, tf, h):
    # Runge-Kutta 4th Order Method [By Bottom Science]
    ys =[]
    t = t0
    y = y0
    while t <= tf:
        k1 = h * f(t, y, q, m, B0, E0)
        k2 = h * f(t + h/2, y + k1/2, q, m, B0, E0)
        k3 = h * f(t + h/2, y + k2/2, q, m, B0, E0)
        k4 = h * f(t + h, y + k3, q, m, B0, E0)
        y = y + (k1 + 2*k2 + 2*k3 + k4) / 6
        t = t + h
        
        ys.append(y)
    return ys

import numpy as np

t0 = 0
x0 = np.array([0, 0, 0])
v0 = np.array([1, 1, 0])
Binitial = np.array([B0,0,0])
Einitial = np.array([0,0,.00001])
initial_conditions = np.concatenate((x0, v0))

y0 = initial_conditions
t0 = 0
tf = 3600
h = 0.01

#positions2 = rk4_solver(Lorentzv2, y0, t0, qcharge,me,Binitial, Einitial, tf, h)
positions2=rk4_solver(LorentzF,y0,t0,qcharge,me,Binitial, Einitial, tf, h)
positions2 = np.array(positions2)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot3D(positions2[:, 0], positions2[:, 1], positions2[:, 2])

# print("Solution at t = ", tf, " is: ", y_sol)


# ODE int solver: (also RungeKutta 5)
r = ode(Lorentzv2).set_integrator('dopri5')
#r = ode(Lorentzv2).set_integrator('dopri5')
t0 = 0
x0 = np.array([0, 0, 0])
v0 = np.array([1, 1, 0])
initial_conditions = np.concatenate((x0, v0))
B0 = 3e-5 # mean vlaue of B field at equator on earth's surface (31.2 muT)
Binitial = np.array([B0,0,0])
Einitial = np.array([0,0,.00001])
#r.set_initial_value(initial_conditions, t0).set_f_params(1.0, 1.0, 1.0)
r.set_initial_value(initial_conditions, t0).set_f_params(1, 1, Binitial,Einitial)

positions = []
tf = 3600
dt = 5
while r.successful() and r.t < tf:
    r.integrate(r.t+dt)
    #print(r.t)
    positions.append(r.y[:3]) # keeping only position, not velocity

positions = np.array(positions)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2])



# B1 = np.array([x0[0], x0[1], -1])
# B2 = np.array([60, 0, 0])
# B_axis = np.vstack((B1, B1 + B2))
# E1 = B1 = np.array([1, x0[1], x0[2]])
# E2 = np.array([60, 0, 0])
# E_axis = np.vstack((E1, E1 + E2))

# ax.plot3D(B_axis[:, 0], 
#           B_axis[:, 1],
#           B_axis[:, 2])
plt.xlabel('x')
plt.ylabel('y')
ax.set_zlabel('z')
#ax.text3D((B1 + B2)[0], (B1 + B2)[1], (B1 + B2)[2], "B field")
#%% Combined Lorentz and Bfield calculations

R_e = 6371200 # radius of the earth (m), 6371.2 km 
B0 = 312e-7 # mean vlaue of B field at equator on earth's surface (31.2 muT)
alphaTilt = np.radians(11.7) # tilt of the earth
mp = 1.6e-27 #mass of proton
me = 9.1e-31
mu = -7.94e22*np.array([.0,np.sin(alphaTilt),np.cos(alphaTilt)])
r0dip = np.array([0,0,0])
m0 = 1e-7
def B(r,r0,mu):
    r = np.array([r[0]-r0[0],r[1]-r0[1],r[2]-r0[2]])*R_e
    rmag = np.sqrt(r[0]**2+r[1]**2+r[2]**2)
    Bfield = m0*(3*r*np.dot(mu,r)/(rmag**5)-mu/(rmag**5)-mu/(rmag**3))
    return Bfield

dt =0.0001
tf = 10.
nsteps = int(tf/dt)
t = np.zeros(nsteps)
rp =np.zeros((len(t),3))
vp = np.zeros((len(t),3))
m=4*me
q=2*qcharge
t[0] = 0.
rp[0,:] = np.array([5. , 5., 5.])
vp[0,:] = np.array([1., 1., 1. ])

for i in np.arange(1,nsteps):
    rp1 = rp[i-1,:]
    vp1 = vp[i-1,:]
    ap1 = q/m *np.cross(vp1,B(rp1,r0dip,mu))
    
    rp2 = rp[i-1,:] + 0.5*vp1*dt
    vp2 = vp[i-1,:]+0.5*ap1*dt
    ap2 = q/m*np.cross(vp2,B(rp2,r0dip,mu))
    
    rp3 = rp[i-1,:] +0.5*vp2*dt
    vp3 = vp[i-1,:]+0.5*ap2*dt
    ap3 = q/m*np.cross(vp3,B(rp3,r0dip,mu))
    
    rp4 = rp[i-1,:] + vp3*dt
    vp4 = vp[i-1,:] + ap3*dt
    ap4 = q/m*np.cross(vp4,B(rp4,r0dip,mu))
    
    rp[i] = rp[i-1,:]+(dt/6.0)*(vp1+2*vp2+2*vp3+vp4)
    vp[i] = vp[i-1,:]+(dt/6.0)*(ap1+2*ap2+2*ap3+ap4)
    t[i] = dt*i


fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot3D(rp[:, 0], rp[:, 1], rp[:, 2])
ax.plot3D(rp[0,0],rp[0,1],rp[0,2],'.')
#%%
from tempfile import NamedTemporaryFile
import base64 
from matplotlib import animation

VIDEO_TAG = """<video controls>
 <source src="data:video/x-m4v;base64,{0}" type="video/mp4">
 Your browser does not support the video tag.
</video>"""

def anim_to_html(anim):
    if not hasattr(anim, '_encoded_video'):
        f = NamedTemporaryFile(suffix='.mp4', delete=False)
        anim.save(f.name, fps=20, extra_args=['-vcodec', 'libx264', '-pix_fmt', 'yuv420p'])
        f.flush()
        video = open(f.name, "rb").read()
        f.close()
        anim._encoded_video = base64.b64encode(video).decode('utf-8')
    
    return VIDEO_TAG.format(anim._encoded_video)
from IPython.display import HTML

def display_animation(anim):
    plt.close(anim._fig)
    return HTML(anim_to_html(anim))


def compute_trajectory(m, q):
    r = ode(Lorentzv2).set_integrator('dopri5')
    dist = 2*R_e
    th = 0
    r.set_initial_value(initial_conditions, t0).set_f_params(m, q,Bdipcart(m,r.y[0],r.y[1],r.y[2]), [0,0,0])
    #r.set_initial_value(initial_conditions, t0).set_f_params(m, q,[1,0,0], [0,0,0])
    positions = []
    t1 = 2000
    
    dt = 0.05
    while r.successful() and r.t < t1:
        dist = np.sqrt(r.y[0]**2+r.y[1]**2+r.y[2]**2)
        th = np.arctan2(np.sqrt(r.y[0]**2+r.y[1]**2),r.y[2])
        r.set_f_params(m, q, Bdipcart(m,r.y[0],r.y[1],r.y[2]),[0,0,0])
        #r.set_f_params(m, q, [1,0,0],[0,0,0])
        r.integrate(r.t+dt)
        positions.append(r.y[:3])

    return np.array(positions)

positions = []
# for m, q in zip([1, 0.1, 1, 0.1], [1, 1, -1, -1]):
#     positions.append(compute_trajectory(m, q))
  

for m, q in zip([me], [qcharge]):
    positions.append(compute_trajectory(m, q))
  

from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
for position in positions:
    ax.plot3D(position[:, 0], position[:, 1], position[:, 2])
plt.xlabel('x')
plt.ylabel('y')
ax.set_zlabel('z')

# FRAMES = 100
# fig = plt.figure()
# ax = fig.add_subplot(111, projection='3d')

# def init():
#     ax.set_xlabel('x')
#     ax.set_ylabel('y')
#     ax.set_zlabel('z')
    
# # animation function.  This is called sequentially
# def animate(i):
#     current_index = int(positions[0].shape[0] / FRAMES * i)
#     ax.cla()
#     for position in positions:
#         ax.plot3D(position[:current_index, 0], 
#                   position[:current_index, 1], 
#                   position[:current_index, 2])
#     ax.set_xlabel('x')
#     ax.set_ylabel('y')
#     ax.set_zlabel('z')
# # call the animator.
# anim = animation.FuncAnimation(fig, animate, init_func=init,
#                                frames=FRAMES, interval=100)

# # call our new function to display the animation
# display_animation(anim)

#%% Rotating Earth's Magnetic Field - 3D
# 3D plot of the magnetic vector field
R_e = 6371200 # radius of the earth (m), 6371.2 km 
B0 = 312e-7 # mean vlaue of B field at equator on earth's surface (31.2 muT)
alphaTilt = np.radians(11.7) # tilt of the earth
mp = 1.6e-27 #mass of proton

# define magnetic field components of a dipole
def Bdip(r,theta):
    Br = -2*B0*(R_e/r)**3*np.cos(theta+alphaTilt)
    Btheta = -B0*(R_e/r)**3*np.sin(theta+alphaTilt)
    return Br, Btheta

def Bdipcart(m,x,y,z):
    r = np.sqrt(x**2+y**2+z**2)
    Bx = 3*m*mu0/(4*np.pi*r**5)*x*z
    By = 3*m*mu0/(4*np.pi*r**5)*y*z
    Bz = m*mu0/(4*np.pi*r**5)*(z**2-r**2)
    return Bx,By,Bz

def Bdipsherical(m,r,theta):
    Br = 2*mp*mu0/(4*np.pi*r**3)*np.cos(theta+alphaTilt)
    Btheta = mp*mu0/(4*np.pi*r**3)*np.sin(theta+alphaTilt)
    return Br,Btheta


def E(u,B):
    return np.cross(-u,B)
    
'##########'
# #cartesian coords testing
# #define cartesian coordinates
# x = np.linspace(-4*R_e,4*R_e,10)
# y = np.linspace(-4*R_e,4*R_e,10)
# z = np.linspace(-4*R_e,4*R_e,10)
# [X,Y,Z] = np.meshgrid(x,y,z)



# # calculate the magentic field
# [Bx,By,Bz] = Bdipcart(mp,X,Y,Z)

# #save Bx, By, Bz values
# Bxinitial = np.array(Bx)
# Byinitial = np.array(By)
# Bzinitial = np.array(Bz)
# # print(Bx[0,0,0])
# # print(Bxinitial[0,0,0])


# # plot
# fig = plt.figure()
# ax = fig.gca(projection='3d')
# #ax.quiver(r,lam,phi,Br,Btheta,Bphi,normalize=True)
# ax.quiver(X,Y,Z,Bx,By,Bz,length=70e5,normalize=True)
# ax.set_xlabel('X')
# ax.set_ylabel('Y')
# ax.set_zlabel('Z')
'############'


def lshell(L,theta):
    r = R_e*L*np.sin(np.pi/2-theta)**2
    return r


''#####################################################
# test line 3d plot
azi = np.linspace(0,2*np.pi,10)
fig = plt.figure()
ax = fig.gca(projection='3d')
thetaangle = np.linspace(0,2*np.pi,100)
lshells = [3]
#lshells = [2,3,4]


for l in np.arange(len(lshells)):
    radius = lshells[l]*R_e
    rs = np.linspace(R_e,radius,5)
    rcorrect = lshell(l,thetaangle)
    for R in np.arange(len(rs)):
        [Br,Btheta] = Bdip( rs[R], thetaangle)
        Bphi = np.zeros(azi.shape)
        for i in np.arange(len(azi)):
            Bx = Br*np.sin(thetaangle)*np.cos(azi[i]) + Btheta*np.cos(thetaangle)*np.cos(azi[i]) 
            By = Br*np.sin(thetaangle)*np.sin(azi[i]) + Btheta*np.cos(thetaangle)*np.sin(azi[i]) 
            Bz = Br*np.cos(thetaangle) - Btheta*np.sin(thetaangle)
            
            Bxc = rcorrect*np.sin(thetaangle)*np.cos(azi[i]) + Btheta*np.cos(thetaangle)*np.cos(azi[i]) 
            Byc = rcorrect*np.sin(thetaangle)*np.sin(azi[i]) + Btheta*np.cos(thetaangle)*np.sin(azi[i]) 
            Bzc = rcorrect*np.cos(thetaangle) - Btheta*np.sin(thetaangle)
            
            #ax.quiver(r,lam,phi,Br,Btheta,Bphi,normalize=True)
           
            ax.plot3D(Bxc,Byc,Bzc,'k')
            #ax.plot3D(Bx,By,Bz,'k')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')


''#######################################################
alphaTilt = np.radians(11.7)
def lshell(L,theta):
    r = R_e*L*np.sin(np.pi/2-theta)**2
    return r

#L = np.arange(2,7,1)
L=[2]
thetas = np.linspace(.001,2*np.pi,100)
xs=[]
ys=[]
zs =[]

R_e = 6371200
azimuthal = np.linspace(0,2*np.pi,100)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

for i in range(len(L)):
    for t in range(len(thetas)):
        for a in range(len(azimuthal)):
            r = lshell(L[i],thetas[t])
            # x = r*np.cos(thetas[t])
            # y = r*np.sin(thetas[t])
            # xs.append(x)
            # ys.append(y)
            x= r*np.sin(thetas[t])*np.cos(azimuthal[a])
            z=r*np.sin(thetas[t])*np.sin(azimuthal[a])
            y=r*np.cos(thetas[t])
            xs.append(x)
            ys.append(y)
            zs.append(z)
            
    
    # ax.plot(xs,ys)
    # ax.text(lshell(L[i],0)*np.cos(0),lshell(L[i],np.pi/2)*np.sin(np.pi/2),str(L[i]))
    

    ax.plot3D(xs,ys,zs)


# Add a filled circle for the Earth
#ax.add_patch(Circle((0,0), R_e, color='b', zorder=100))
#ax.set_aspect('equal', adjustable='box')
plt.xlabel('x (m)')
plt.ylabel('y (m)')
#%%
#define cartesian coordinates
x = np.linspace(-4*R_e,4*R_e,10)
y = np.linspace(-4*R_e,4*R_e,10)
z = np.linspace(-4*R_e,4*R_e,10)
[X,Y,Z] = np.meshgrid(x,y,z)

# translate into sphereical coordinates
r = np.sqrt(X**2+Y**2+Z**2)
theta = np.arccos(Z/np.sqrt(X**2+Y**2+Z**2))
phi = np.sign(Y)*np.arccos(X/np.sqrt(X**2+Y**2))



# calculate the magentic field
[Br,Btheta] = Bdip(r,theta)
[Br,Btheta] = Bdipsherical(mp, r, theta)
Bphi = np.zeros(phi.shape)

# translate magnetic field into cartesian coordinates
Bx = Br*np.sin(theta)*np.cos(phi) + Btheta*np.cos(theta)*np.cos(phi) 
By = Br*np.sin(theta)*np.sin(phi) + Btheta*np.cos(theta)*np.sin(phi) 
Bz = Br*np.cos(theta) - Btheta*np.sin(theta)
#save Bx, By, Bz values
Bxinitial = np.array(Bx)
Byinitial = np.array(By)
Bzinitial = np.array(Bz)
# print(Bx[0,0,0])
# print(Bxinitial[0,0,0])

Ex = np.zeros(np.shape(Bx))
Ey = np.zeros(np.shape(Bx))
Ez = np.zeros(np.shape(Bx))

# plot
fig = plt.figure()
ax = fig.gca(projection='3d')
#ax.quiver(r,lam,phi,Br,Btheta,Bphi,normalize=True)
ax.quiver(X,Y,Z,Bx,By,Bz,length=70e5,normalize=True)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')


### Rotation of the Earth:
# define parameter space
rotvel = 7.292e-5 # rotational velocity of the earth in radians/second
dt = 3600/10 # time step (s)
nhours = 4 # number of hours in our range
tarray = np.arange(0,3600*nhours,dt) # array of times for half a day (s)

# rotation matrix function
# def rotation(rotangle,r):
#     Rz = np.matrix([[r*np.cos(rotangle),-r*np.sin(rotangle),0],[r*np.sin(rotangle),r*np.cos(rotangle),0],[0,0,r*1]])
#     return Rz
def rotation(rotangle):
    Rz = np.matrix([[np.cos(rotangle),-np.sin(rotangle),0],[np.sin(rotangle),np.cos(rotangle),0],[0,0,1]])
    return Rz

def E(u,B):
    return np.cross(-u,B)

n = 0
m= 5
l = 5
# Badd = np.zeros(Bx.shape)
# Badd[n,m,l] = Badd[n,m,l]+1.e-6
# Bx = Bx +Badd
# Bxinitial = Bx


# Define the meta data for the movie
FFMpegWriter = manimation.writers['ffmpeg']
metadata = dict(title='Movie Test', artist='Matplotlib',
                comment='roation of earths magnetic field')
writer = FFMpegWriter(fps=4, metadata=metadata)
# plot
fig = plt.figure()
ax = fig.gca(projection='3d')
# to plot sphere as earth:
r = R_e
u = np.linspace(0,2*np.pi,100)
v = np.linspace(0,2*np.pi,100)
u,v = np.meshgrid(u,v)
xearth= r*np.cos(u)*np.sin(v)
yearth = r*np.sin(u)*np.sin(v)
zearth = r*np.cos(v)
# plotting starting B field
ax.quiver(X,Y,Z,Bx,By,Bz,length=70e5,normalize=True) # magnetic field
ax.plot_surface(xearth,yearth,zearth, cmap=plt.cm.terrain) # earth
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
r = lambda x,y,z: np.sqrt(x**2+y**2+z**2)
with writer.saving(fig, "C:/Users/jmcle/OneDrive/Documents/PhD Iowa/Electro Dynm I/Project 2/rotating_earth_Bfield.mp4", 180):
        
    # start rotating
    for t in tarray:
        #print('Binitial: '+str(Bxinitial[0,0,0]))
        rotangle = rotvel*dt # how much earth rotated in time t
        Rz = rotation(rotangle) # rotation matrix
        Bxprev = np.array(Bx) # save B and positions to calculate rotation
        Byprev = np.array(By)
        Bzprev = np.array(Bz)
        xprev = np.array(X)
        yprev = np.array(Y)
        zprev = np.array(Z)
        for i in np.arange(len(x)):     # loop through each positional point
            for j in np.arange(len(y)):
                for k in np.arange(len(z)):
                    Bx0 = Bxprev[i,j,k] # specific B vector to rotate 
                    By0 = Byprev[i,j,k]
                    Bz0 = Bzprev[i,j,k]
                    B0matrix = np.matrix([[Bx0],[By0],[Bz0]])
                    [Bxf,Byf,Bzf] = Rz@B0matrix   # rotate B vector
                    Bx[i,j,k] = Bxf[0,0] # value packaged in martix
                    By[i,j,k] = Byf[0,0]
                    Bz[i,j,k] = Bzf[0,0]
                    R = r(X[i,j,k],Y[i,j,k],Z[i,j,k])
                    
                    phi = np.sign(X[i,j,k])*np.arccos(X[i,j,k]/np.sqrt(X[i,j,k]**2+Y[i,j,k]**2))
                    v = np.array([rotvel*R*np.cos(phi), rotvel*R*np.sin(phi), 0])
                    
                    Bs = np.array([Bx[i,j,k],By[i,j,k],Bz[i,j,k]])
                    
                    Efield = np.cross(-v.T,Bs.T)
                    #print(Efield)
                    Ex[i,j,k]= Efield[0]
                    Ey[i,j,k]= Efield[1]
                    Ez[i,j,k]= Efield[2]
                    x0 = xprev[i,j,k] 
                    y0 = yprev[i,j,k]
                    z0 = zprev[i,j,k]
                    posmatrix = np.matrix([[x0],[y0],[z0]])
                    [xf,yf,zf] = Rz@posmatrix # rotate position 
                    X[i,j,k] = xf[0,0]
                    Y[i,j,k] = yf[0,0]
                    Z[i,j,k] = zf[0,0]
        
        #print('Bx: '+str(Bx[0,0,0]))        
        #fig = plt.figure()
        ax.clear()
        ax = fig.gca(projection='3d')
        ax.quiver(X,Y,Z,Bx,By,Bz,length=70e5,normalize=True,alpha = 0.7) # magnetic field
        ax.quiver(X[n,m,l],Y[n,m,l],Z[n,m,l],Bx[n,m,l],By[n,m,l],Bz[n,m,l],length=80e5,normalize=True,color='r')
        ax.quiver(X,Y,Z,Ex,Ey,Ez,length=70e5,normalize=True,alpha = 0.7,color='g') # electric field
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title('Time = '+str(t/3600)+' hours')
        ax.plot_surface(xearth,yearth,zearth, cmap=plt.cm.gist_earth) # earth
        writer.grab_frame()
        
